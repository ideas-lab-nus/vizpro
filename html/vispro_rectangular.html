<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">


    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <script src="https://d3js.org/d3-path.v1.min.js"></script>
    <script src="https://d3js.org/d3-shape.v1.min.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/5.9.0/math.js"></script>


    <!-- 
    <script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
<script src="https://d3js.org/d3-ease.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
<script src="https://d3js.org/d3-selection.v1.min.js"></script>
<script src="https://d3js.org/d3-timer.v1.min.js"></script>
<script src="https://d3js.org/d3-transition.v1.min.js"></script>
<script src="https://d3js.org/d3-drag.v1.min.js"></script>
<script src="https://d3js.org/d3-zoom.v1.min.js"></script>
<script>

var zoom = d3.zoom(); -->

    </script>


    <style type="text/css">
        svg {
            border: solid 1px #aaa;
        }

        #checks {
            margin: 10px;
        }

        text {
            /* pointer-events: none; */
            user-select: none;
            font-family: monospace;

        }

        .nodeLog {
            font-size: small;
            font-family: monospace;
            pointer-events: none;
        }

        .component {
            /* pointer-events: none; */

        }


        .output {
            font-family: monospace;
            font-size: small;
            color: white;
        }

        .input {
            font-family: monospace;
            font-size: small;
        }

        .nodetitle {
            font-family: monospace;
            font-size: 13.2px;
            font-weight: bold;
            pointer-events: none;
        }


        div#someData {
            padding: 8px;
            padding-top: 25px;
            /* padding: 6px; */
            font-size: x-small;
            font-family: monospace;
        }




        circle {
            cursor: pointer;
        }

        div#PropertiesBarSelector {
            width: 3px;
            /* height: 100%; */
            position: fixed;
            right: 201px;
            background-color: #969696;
            border-left: 1px solid #efefef;
            box-shadow: inset 1px 0px 2px #565656;
            height: 100%;
            top: 0px;
            cursor: ew-resize;
        }

        div#PropertiesBar {
            width: 200px;
            background-color: #eaeaea;
            position: fixed;
            right: 0px;
            top: 0px;
            height: 100%;
        }

        div#mainGrid {
            position: absolute;
            top: 0px;
            left: 0px;
        }

        div#mainGrid {
            background-color: #e4e4e4;
            background-image: url(https://www.freeiconspng.com/uploads/white-grid-png-29.png);
            /* background-size: 20%; */
        }

        div#textAreaBox {
    position: fixed;
    top: 0px;
    left: 0px;
    opacity: 0.8;
}
    </style>
    <title>Document</title>
</head>

<body>
    <div class="ui-designer-grid" id="mainGrid">
        <svg height="6000" width="6000">
            <defs>
                <filter id="f2" x="-40" y="-40" width="150%" height="150%" filterUnits="userSpaceOnUse">
                    <feOffset result="offOut" in="SourceGraphics" dx="0" dy="0" />
                    <feGaussianBlur result="blurOut" in="offOut" stdDeviation="1" />
                    <feBlend in="SourceGraphic" in2="blurOut" mode="normal" />
                </filter>
            </defs>
            <!-- <rect width="90" height="90" stroke="green" stroke-width="3"
            fill="yellow" filter="url(#f2)" /> -->
        </svg>
    </div>
    <div id="textAreaBox" style="display:none"><textarea id="TextAreaSelector"></textarea></div>

    <div id="PropertiesBar">
        <button id="addComp">Add comp</button>
        <button id="addSlider">Add Slider</button>

        <div id="someData">SourceGraphic

        </div>
    </div>
    <div id="PropertiesBarSelector">


    </div>
    <script>
        allComp = []
        allEdges = []
        comp_input_edges = {}
        comp_output_edges = {}

        function uuidv4(ini) {
            return ini + 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0,
                    v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function addEdge(from, to, fromComp, toComp) {
            initLink = {
                "GUID": uuidv4("E"),
                "path": null,
                "X1": 0,
                "Y1": 0,
                "X2": 10,
                "Y2": 10,
                "from": from,
                "to": to,
                "fromComp": fromComp,
                "toComp": toComp
            }

            return initLink;

        }

        function addCircle() {
            initCircle = {
                "GUID": uuidv4("C"),
                "element": null,
                "CX": 0,
                "CY": 0,
                "Comp": null,
                "type": "data",
                "path": null,
            }

            return initCircle;
        };



        Input = {
            "id": 0,
            "circle": null,
            "type": "input",
            "Name": "Input1",
            "ShortName": "X",
            "Description": "input1",
            "Message": "short description",
            "type": "item",
            "datatype": "int",
            "value": 0,
        }
        Output = {
            "id": 0,
            "circle": null,
            "type": "output",
            "Name": "output1",
            "ShortName": "A",
            "Description": "output1",
            "Message": "short description",
            "type": "item",
            "datatype": "int",
            "value": 0,
        }

        function addSlider(guid, min = 0, max = 100, step = 1.0) {
            initSlider = {
                "GUID": guid,
                "X": 0,
                "Y": 0,
                "width": 150,
                "height": 30,
                "Name": "Slider",
                "ShortName": "Num",
                "Description": "Dummy Slider",
                "Message": "short description",
                "min": min,
                "max": max,
                "value": 0,
                "step": step,
                "typeName": null,
                "selection": "selectable",
                "view": "visible", // hidden , disabled
                "fill": "#303952",
                "rect": null,
                
            };

            return initSlider;
        }

        function addcomponent(guid, n_inputs = 4, n_outputs = 5) {
            inputs = []
            outputs = []

            for (let index = 0; index < n_inputs; index++) {
                inputs.push({
                    "id": index,
                    "circle": null,
                    "textObj": null,
                    "Name": "Input" + index.toString(),
                    "ShortName": "In_" + index.toString(),
                    "Description": "input1",
                    "Message": "short description",
                    "type": "item",
                    "datatype": "int",
                    "value": 0,
                })

            }


            for (let index = 0; index < n_outputs; index++) {
                outputs.push({
                    "id": index,
                    "circle": null,
                    "textObj": null,
                    "Name": "Output" + index.toString(),
                    "ShortName": "Out_" + index.toString(),
                    "Description": "output",
                    "Message": "short description",
                    "type": "item",
                    "datatype": "int",
                    "value": 0,
                })

            }
            initComp = {
                "GUID": guid,
                "X": 0,
                "Y": 0,
                "width": 120,
                "height": 50,
                "Name": "Component",
                "ShortName": "Comp",
                "Description": "Dummy component",
                "Message": "short description",
                "numInputs": 3,
                "numOutputs": 2,
                "typeName": null,
                "logo": null,
                "type": "node",
                "state": "unbound",
                "selection": "selectable",
                "view": "visible", // hidden , disabled
                "fill": "#303952",
                "rect": null,
                "inputs": inputs,
                "outputs": outputs,
                "log": {
                    "logText": " Log message output.. "
                }
            };

            return initComp;
        } //End of addcomponent

        var svgContainer = d3.select("svg");

        // CREATE A NEW COMPONENT.
        // TODO : 
        // 1. change this from on button click to be on drop object from the sidebar. 
        // 2. save to the database once created - aslo save to the undo-redo repo.
        $("button#addComp").on('click', function (e) {
            var newcomp = addcomponent(uuidv4("C"), Math.floor(Math.random() * 5) + 1, Math.floor(Math.random() * 5) + 1);
            // ////console.log(newcomp)

            somearr = ["Data point",
                "HVAC",
                "Building",
                "Object",
                "InfluxDB",
                "OSISoft",
                "dataBase",
                "Chiller",
                "Boiler",
                "Dummy",
                "Energy Efficiency Model"
            ];

            allColors = [
                "#f6b93b",
                "#e55039",
                "#4a69bd",
                "#60a3bc",
                "#6a89cc",
                "#fed330",
                "#2bcbba",
                "#26de81",
                "#e74c3c",
                "#95a5a6",
                "#8e44ad",
                "#34495e",
                "#7f8c8d",
            ]
            newcomp.fill = allColors[Math.floor(Math.random() * allColors.length)];
            newcomp.Name = somearr[Math.floor(Math.random() * somearr.length)];
            xx = 8;
            padding = 20;
            titleMargin = 30;
            titleMarginLeft = 30;
            newcomp.height = titleMargin + (Math.max(newcomp.inputs.length, newcomp.outputs.length + 1)) *padding;

            // TODO : get the longest text in the component. and set the width based on this. 
            newcomp.width = newcomp.Name.length * xx + titleMarginLeft;

            var cont = svgContainer.append("g")
                .attr("class", "component")
                .attr("id", newcomp.GUID);

            var node = cont
                .append("g")
                .attr("class", newcomp.type + " " + newcomp.state + " " + newcomp.selection + " " + newcomp
                    .view + " " + newcomp.GUID)
                .attr("id", "comp-" + newcomp.GUID)
                .attr("transform", () => {
                    return "translate(" + Math.random() * 500 + ", " + Math.random() * 500 + ")";
                })

                var InputGroup = node.append('g');
            for (let index = 0; index < newcomp.inputs.length; index++) {
                var inp = InputGroup.append('rect').lower()
                    .attr("width", "15")
                    .attr("height", "10")
                    .attr("transform", "translate(-8,"+(index * padding + titleMargin).toString()+")")
                    .attr("cx", "-3")
                    .attr("cy", (index * padding + titleMargin).toString())
                    .attr("fill", "gray")//newcomp.fill)
                    .attr("r", "5")
                    .attr("stroke", "black")
                    .attr("stroke-width", "2")
                    .attr("id", "inputCir" + newcomp.GUID + "_" + index)
                    .attr("class", "inputCir " + newcomp.GUID + " " + index)
                    .attr("type", function () {
                        newcomp.inputs[index].circle = addCircle();
                        newcomp.inputs[index].circle.element = this;
                        newcomp.inputs[index].circle.CX = 0;
                        newcomp.inputs[index].circle.CY = (index * padding + titleMargin);
                        newcomp.inputs[index].type = "input";
                        return "input";
                    });
            }



            var OutputGroup = node.append('g');
            for (let index = 0; index < newcomp.outputs.length; index++) {
                var out = OutputGroup.append('rect')
                    .attr("width", "8")
                    .attr("height", "10")
                    .attr("transform", "translate("+newcomp.width+","+(index * padding + titleMargin).toString()+")")
                    .attr("cx", newcomp.width)
                    .attr("cy", (index * padding + titleMargin).toString())
                    .attr("fill", "gray")//newcomp.fill)
                    .attr("r", "5")
                    .attr("stroke", "black")
                    .attr("stroke-width", "2")
                    .attr("id", "outputCir" + newcomp.GUID + "_" + index)
                    .attr("class", "outputCir " + newcomp.GUID + " " + index)
                    .attr("type", function () {
                        newcomp.outputs[index].circle = this;
                        newcomp.outputs[index].type = "output";

                        // ////console.log(newcomp.outputs[index]);
                        return "output";
                    }).lower();
            }


            var rect = node.append('rect')
                .attr("class", "CompBody " + newcomp.GUID)
                .attr("id", newcomp.GUID)
                .attr("rx", "3")
                .attr("ry", "3")
                .attr("filter", "url(#f2")
                .attr("stroke-width", "1")
                .attr("stroke", "black")
                .attr("width", newcomp.Name.length * xx + titleMarginLeft)
                .attr("height", newcomp.height)
                .attr("fill", newcomp.fill)
                // .attr("filter", "url('#svgshadow')")
                .on("mouseover", function () {
                    newcomp.rect = this;
                    d3.select(newcomp.rect)
                        // .attr("fill", "#303952")
                        .attr("cursor", "pointer");
                })
                .on("mouseout", function () {
                    newcomp.rect = this;
                    d3.select(newcomp.rect).attr("fill", newcomp.fill)
                })
                .on("dblclick", () => {
                    //console.log("You dobule clicked me ");
                });

            var cirGroup = node.append('g')
                .attr("transform", () => {
                    x = newcomp.width;
                    y = newcomp.height;
                    return "translate(" + (x).toString() + "," + (y - 10).toString() + ")";
                });

            var cir = cirGroup.append("circle")
                .attr("class", "log " + newcomp.GUID)
                .attr("id", "log-" + newcomp.GUID)
                .attr("r", "5")
                .attr("fill", "black")
                .attr("stroke", "white")
                .attr("stroke-width", "2")
                .on('mouseover', () => {
                    d3.select("#nodeLog" + newcomp.GUID).style("display", "block");
                })
                .on('mouseout', () => {
                    d3.select("#nodeLog" + newcomp.GUID).style("display", "none");
                });

            var log = cirGroup.append("text")
                .attr("id", "nodeLog" + newcomp.GUID)
                .attr("class", "nodeLog " + newcomp.GUID)
                .attr("transform", "translate(10, 10)")
                .text(newcomp.log.logText)
                .attr("fill", "black")
                .style("display", "none");


            var Titlegroup = node.append("g")
                .attr("transform", () => {
                    return "translate(0, 15)";
                });


            var Title = Titlegroup.append("text")
                .attr("class", "nodetitle node_title" + newcomp.GUID)
                .text(newcomp.Name)
                .attr("fill", "white")
                .attr("transform", "translate(" + titleMarginLeft / 2.0 + ", 0)")

                var InputGroupText = node.append('g');

                for (let index = 0; index < newcomp.inputs.length; index++) {
                    var inptext = InputGroupText.append('text')
                        .attr("id", "input-" + newcomp.GUID + "_" + index)
                        .attr("class", "inputTxt " + newcomp.GUID + " " + index)
                        .attr("transform", "translate(" + ((newcomp.inputs[index].ShortName.length)).toString() +
                            " , " + (index * padding + titleMargin + 5).toString() + ")")
                        .text(newcomp.inputs[index].ShortName)
                        .attr("fill", "white")
                        .attr("type", function () {
                            newcomp.inputs[index].textObj = this;

                            // ////console.log(newcomp.inputs[index]);
                            return "input";
                        });

                    }
                            
            var OutputGroupText = node.append('g');
            for (let index = 0; index < newcomp.outputs.length; index++) {
                var outtext = OutputGroupText.append('text')
                    .attr("id", "output-" + newcomp.GUID + "_" + index)
                    .attr("class", "outputTxt " + newcomp.GUID + " " + index)
                    .attr("transform", "translate(" + (newcomp.width - (newcomp.outputs[index].ShortName
                            .length * 8)).toString() + " , " + (index * padding + titleMargin + 5).toString() +
                        ")")
                    .text(newcomp.outputs[index].ShortName)
                    .attr("fill", "white")
                    .attr("type", function () {
                        newcomp.outputs[index].circle = this;
                        newcomp.outputs[index].type = "output";

                        return "output";
                    })
                    .attr("type", function () {
                        newcomp.outputs[index].textObj = this;


                        // ////console.log(newcomp.outputs[index]);
                        return "output";
                    });
            }
            allComp.push(newcomp);
            comp_input_edges[newcomp.GUID] = new Array(newcomp.inputs.length);
            comp_output_edges[newcomp.GUID] = new Array(newcomp.outputs.length);




            var mainGrid = d3.select("#mainGrid");
            


            var allcomp = d3.selectAll("rect.CompBody")
                .on('mousedown', function (d, i) {
                    var coordinates = d3.mouse(this);
                    componentClickX = coordinates[0];
                    componentClickY = coordinates[1];

                    clicked = true;
                    var pos = $("#comp-" + this.id).attr("transform").split("translate(")[1].replace(")",
                        "").split(",").map(function (item) {
                        return parseFloat(item, 10);
                    });
                    dragX = pos[0] + x;
                    dragY = pos[1] + y;

                    startDrag = true;
                    clickedId = this.id;
                })


            var fromCircle = addCircle();
            var toCircle = addCircle();
            var toComponent = null;
            var fromComponent = null;

            var allCircles = d3.selectAll("circle")
                .on('mousedown', function () {
                    targetcircleId = this.id;
                    if (edgeStarted && targetcircleIN && this != fromCircle.element) {

                    } else {
                        if (this.classList[0] == "outputCir")
                        {
                            edgeStarted = true;
                        selectedcircleId = this.id;

                        var x = d3.event.pageX;
                        var y = d3.event.pageY;


                        initEdgex1 = x;
                        initEdgey1 = y;
                        null
                        d3.select("svg")
                            .append("path")
                            // .attr("filter", "url(#f2)")
                            .attr("stroke-dasharray", "4")
                            .attr("d", function () {
                                // ////console.log("M "+initEdgex1+" "+initEdgey1+" L "+x+" "+y);
                                return "M " + initEdgex1 + " " + initEdgey1 + " L " + x + " " + y;

                            }).attr('stroke', "black")
                            .attr("stroke-width", "1")
                            .attr("id", "Path" + this.id);
                        selectedcircleId = "Path" + this.id;
                        fromCircle.element = this;
                        }
                    }



                })
                .on("mouseover", function () {
                    targetcircleIN = true;
                })
                .on("mouseup", function () {
                    //This event is called when the mouse cursor is inside the input circle, this means that the line is now complete and ready to be created. 

                    if (edgeStarted && targetcircleIN && this != fromCircle.element) {
                        toCircle.element = this;
                        //toCircle: refers to the input circle of the other component, on which the mouse cursor is moving on right now. 
                        //when the mouse button is released, the link between this circle and the fromCircle will be drawn, and the data
                        //will flow from the "fromCircle" to the "toCircle"
                        thisEdge = addEdge(fromCircle, toCircle, fromCircle.element.classList, toCircle
                            .element.classList);
                        // once the mouse button is released on this circle,the edge is initiated. 


                        // TODO-7 : There is a bug here, becuase if you have already created a connection before and then deleted it, it still not deleted from the main component.
                        thisPath = d3.select("#" + selectedcircleId)
                        thisEdge.path = thisPath["_groups"][0];


                        // Those 2 lines append the component-edge matrix
                        if (comp_input_edges[toCircle.element.classList[1]][toCircle.element.classList[
                                2]] == undefined) {
                            comp_input_edges[toCircle.element.classList[1]][toCircle.element.classList[
                                2]] = [thisEdge.path[0].id]
                        } else {
                            comp_input_edges[toCircle.element.classList[1]][toCircle.element.classList[2]]
                                .push(thisEdge.path[0].id)
                        }

                        if (comp_output_edges[fromCircle.element.classList[1]][fromCircle.element.classList[
                                2]] == undefined) {
                            comp_output_edges[fromCircle.element.classList[1]][fromCircle.element.classList[
                                2]] = [thisEdge.path[0].id]
                        } else {
                            comp_output_edges[fromCircle.element.classList[1]][fromCircle.element.classList[
                                2]].push(thisEdge.path[0].id)
                        }

                        //console.log(comp_input_edges)

                        allEdges.push(thisEdge);
                        edgeStarted = false;
                        updateAll();


                    } else {

                    }
                });

        });

        $("button#addSlider").on('click', function (e) {


            //console.log("Adding Slider ....")
            var newSlider = addSlider(uuidv4("S"), 0, 100, 1.0);
            // ////console.log(newcomp)


            allColors = [
                "#f6b93b",
                "#e55039",
                "#4a69bd",
                "#60a3bc",
                "#6a89cc",
                "#fed330",
                "#2bcbba",
                "#26de81",
                "#e74c3c",
                "#95a5a6",
                "#8e44ad",
                "#34495e",
                "#7f8c8d",
            ]

            newSlider.fill = "#7f8fa6"; //allColors[Math.floor(Math.random() * allColors.length)];
            newSlider.Name = "slider";
            xx = 8;
            padding = 20;
            titleMargin = 30;
            titleMarginLeft = 5;
            newSlider.height = 20;
            newSlider.width = 250;

            var cont = svgContainer.append("g")
                .attr("class", "slider")
                .attr("id", newSlider.GUID);

            var node = cont
                .append("g")
                .attr("class", "SliderGroup" + " " + newSlider.selection + " " + newSlider
                    .view + " " + newSlider.GUID)
                .attr("id", "comp-" + newSlider.GUID)
                .attr("transform", () => {
                    return "translate(" + Math.random() * 500 + ", " + Math.random() * 500 + ")";
                })



            var rect = node.append('rect')
                .attr("class", "CompBody " + newSlider.GUID)
                .attr("id", newSlider.GUID)
                .attr("rx", "3")
                .attr("ry", "3")
                .attr("filter", "url(#f2")
                .attr("stroke-width", "1")
                .attr("stroke", "#3a4c69")
                .attr("width", newSlider.width)
                .attr("height", newSlider.height)
                .attr("fill", newSlider.fill)
                // .attr("filter", "url('#svgshadow')")
                .on("mouseover", function () {
                    newSlider.rect = this;
                    d3.select(newSlider.rect)
                        // .attr("fill", "#303952")
                        .attr("cursor", "pointer");
                })
                .on("mouseout", function () {
                    newSlider.rect = this;
                    d3.select(newSlider.rect).attr("fill", newSlider.fill)
                })
                .on("dblclick", () => {
                    //console.log("You dobule clicked me ");
                });
            
            var ValueTextGroup = node.append("g")
            .attr("transform", ()=>
            {
                return ("translate(150, -18)")
            });

            var ValueTextRect = ValueTextGroup.append("rect")
            .attr("cx", "0")
            .attr("cy","0")
            .attr("rx", "5")
            .attr("ry", "5")
            .attr("fill", "black")
            .attr("width", "100")
            .attr("height", "15")
            .attr("opacity", "0.5");

            var ValueText = ValueTextGroup.append("text")
            .attr("id", "sliderValueText_"+newSlider.GUID)
            .attr("class", "sliderValueText "+newSlider.GUID)
            .attr("transform", "translate(2, 12)")
            .attr("fill", "white")
            .text(newSlider.value.toString());

            var Titlegroup = node.append("g")
                .attr("transform", () => {
                    return "translate(0, 15)";
                });

            var Title = Titlegroup.append("text")
                .attr("class", "sliderTitle slider_title" + newSlider.GUID)
                .text(newSlider.Name)
                .attr("fill", "white")
                .attr("transform", "translate(" + titleMarginLeft / 2.0 + ", 0)")

            var SlidingGroup = node.append("g")
                .attr("transform", "translate(60, 0)");

            var slidingRectContainer = SlidingGroup.append("rect")
                // .attr("fill", "#576579")
                .attr("height", "3")
                .attr("width", "185")
                .attr("rx", "2")
                .attr("ry", "2")
                .attr("transform", "translate(0, 8)")
                .attr("stroke", "#677184")

            var slidingline = SlidingGroup.append("line")
                .attr("x1", "2")
                .attr("y1", "11")
                .attr("x2", "184")
                .attr("y2", "11")
                // .attr("d", "M 0,0 L 190,0")
                .attr("stroke", "gray")
                .attr("stroke-width", "1")

            var slidingAnchor = SlidingGroup.append("rect")
                .attr("id", "SliderAnchor_" + newSlider.GUID)
                .attr("width", "10")
                .attr("height", "15")
                .attr("rx", "5")
                .attr("ry", "5")
                .attr("fill", "#3a4d69")
                .attr("transform", "translate(60, 3)")
                .on("mouseover", function () {
                    d3.select(this)
                        .attr("fill", "#536c94")
                        .attr("cursor", "pointer")
                        .attr("stroke", "black");
                })
                .on("mouseleave", function () {
                    d3.select(this)
                        .attr("fill", "#3a4d69")
                        .attr("stroke", "none");
                })
                .on("mousedown", function () {
                    sliderRectId = this.id;
                    SliderAnchorclicked = true;
                })
                .on("mouseup", function () {
                    SliderAnchorclicked = false;
                });

            theRequiredSliderGroup = undefined;

            //Moving the slider body
            var allcomp = d3.selectAll("g.SliderGroup")
                .on('mousedown', function (d, i) {
                    theRequiredSliderGroup = this;
                });


                        var allcomp = d3.selectAll("rect.CompBody")
                .on('mousedown', function (d, i) {
                    var coordinates = d3.mouse(this);
                    componentClickX = coordinates[0];
                    componentClickY = coordinates[1];
                    clicked = true;
                    var pos = $("#comp-" + this.id).attr("transform").split("translate(")[1].replace(")",
                        "").split(",").map(function (item) {
                        return parseFloat(item, 10);
                    });
                    dragX = pos[0] ;
                    dragY = pos[1] ;

                    startDrag = true;
                    clickedId = this.id;
                })
        });


        function updateAll() {

            allEdges.forEach(element => {
                thisD = element.path[0].attributes.d.value;
                d3.select("#" + element.path[0].id)
                    .attr("stroke-width", "2")
                    .attr("d", function () {
                        return thisD.replace("L", "C");
                    })
                    .attr("stroke-dasharray", "0")
                    .attr("stroke", "rgb(48, 57, 82)")
                    .attr("stroke-linecap", "round")
                    .attr("stroke-opacity", "0.7").lower();

                ////console.log(element);
            });
        }


        function toMoveEdgeEnds(mainObj) {
            mainObj.inputs.forEach(input => {


            });
        }

        function returnCurveString(x1, y1, x2, y2) {
            coalignValue = 150.0;
            if (x2<x1)
            {
                coalignValue = Math.abs(y2 - y1) / 2.0 + Math.abs(x2-x1);
            }else
            {
                coalignValue = Math.abs(y2 - y1) / 2.0;
            }

            //console.log(coalignValue)
            return "M " + x1 + "," + y1 + " " +
                "C " + (((x1 + x2) / 2.0) + coalignValue).toString() + "," + y1 +
                " " + (((x1 + x2) / 2.0) - coalignValue).toString() + "," + y2 +
                " " + x2 + "," + y2;
        }




        var mainGrid = d3.select("#mainGrid")
            .style("backgroud-color", function () {
                xGrid = this.offsetLeft;
                yGrid = this.offsetTop;
                return "white";
            })




            var SliderAnchorclicked = false;
            var dragX = 0;
            var dragY = 0;

            var sliderRectId = "";
            var componentClickX = 0;
            var componentClickY = 0;



            var initPos = null;
            var startDrag = false;

            clickedId = "";
            var dragX = 0;
            var dragY = 0;

            deltaX = 0;
            deltaY = 0;
            clicked = false;

            var edgeStarted = false;
            var targetcircleIN = false;

            var selectedcircleId = "";
            var targetcircleId = "";
            var selectedSliderAnchorId = "";

            var xGrid = 0;
            var yGrid = 0;



            var initEdgex2 = 0;
            var initEdgey2 = 0;

            var componentClickX = 0;
            var componentClickY = 0;
        d3.select("#mainGrid")
            .on('mousemove', function () {
                mousex = d3.event.pageX;
                mousey = d3.event.pageY;
                var x = mousex - componentClickX;
                var y = mousey - componentClickY;
                if (startDrag) {
                    thisMovingObj = d3.select("#comp-" + clickedId)
                        .attr("transform", function () {
                            return "translate(" + x + "," + y + ")"
                        });

                    allComp.forEach(element => {
                        if (element.GUID == clickedId) {

                            //
                            //TODO [DONE][EfficiencyPlanA-4] This search is so much inefficient, to be replaced 

                            for (let index = 0; index < comp_input_edges[clickedId]
                                .length; index++) {
                                if (comp_input_edges[clickedId][index] != undefined) {
                                    comp_input_edges[clickedId][index].forEach(inputElement => {
                                        circleindex = index;
                                        rectId = clickedId;
                                        rectpos = $("#comp-" + rectId).attr("transform")
                                            .replace("translate(", "").replace(")", "")
                                            .split(",").map(function (item) {
                                                return parseFloat(item, 10);
                                            });
                                        xy2 = $("#" + inputElement).attr("d").split(
                                            " ")[1].split(",").map(function (item) {
                                            return parseFloat(item, 10);
                                        });
                                        var thenewEdge = d3.select("#" + inputElement)
                                            .attr("d", function () {
                                                itisthelocation = returnCurveString(
                                                    xy2[0], xy2[1], rectpos[0],
                                                    rectpos[1] + (circleindex *
                                                        padding + titleMargin));
                                                return itisthelocation;
                                            });
                                    });
                                }
                            }
                            for (let index = 0; index < comp_output_edges[clickedId]
                                .length; index++) {
                                if (comp_output_edges[clickedId][index] != undefined) {
                                    comp_output_edges[clickedId][index].forEach(
                                        outputElement => {
                                            circleindex = index;
                                            rectId = clickedId;
                                            rectpos = $("#comp-" + rectId).attr("transform")
                                                .replace("translate(", "").replace(")", "")
                                                .split(",").map(function (item) {
                                                    return parseFloat(item, 10);
                                                });
                                            rectwidth = $("rect#" + rectId).attr("width");
                                            xy2 = $("#" + outputElement).attr("d").split(
                                                " ")[5].split(",").map(function (item) {
                                                return parseFloat(item, 10);
                                            });
                                            var thenewEdge = d3.select("#" + outputElement)
                                                .attr("d", function () {
                                                    itisthelocation = returnCurveString(
                                                        rectpos[0] + parseFloat(
                                                            rectwidth), rectpos[1] +
                                                        (circleindex * padding +
                                                            titleMargin), xy2[0],
                                                        xy2[1]);
                                                    return itisthelocation;

                                                });
                                        });
                                }
                            }
                        }
                    });
                }
                if (edgeStarted) {
                    d3.select("#" + selectedcircleId)
                        .attr("d", function () {

                            return "M " + initEdgex1 + "," + initEdgey1 +
                                " C " + ((mousex - 2 + initEdgex1) / 2.0 + Math.abs(mousey -
                                    initEdgey1) / 1.0).toString() + "," + (initEdgey1).toString() +
                                " " + ((mousex - 2 + initEdgex1) / 2.0 - Math.abs(mousey -
                                    initEdgey1) / 1.0).toString() + "," + (mousey - 2).toString() +
                                " " + (mousex - 2).toString() + "," + (mousey - 2).toString();


                        }).attr("fill", "none")
                        .attr("stroke-opacity", "0.2")
                        .attr("interpolate", "basis");
                }

                if (SliderAnchorclicked) {
                        
                        var sliderLineStartingpositionX = 60;
                        var sliderLineStartingpositionY = 3.0;
                        var sliderLineEndingpositionX = 238;
                        var sliderLineEndingpositionY = 3.0;

                        var coordinates = d3.mouse(theRequiredSliderGroup);
                        componentClickX = coordinates[0];
                        componentClickY = coordinates[1];

                        sliderValue = 60;

                        sliderY1 = 100.0;                                                    // Y0
                        sliderX1 = 0.0;                                                      // X0

                        sliderX0 = 0.0;                                                     // X1
                        var ax = 100.0/(sliderLineEndingpositionX - sliderLineStartingpositionX); // Y1


                        

                        // //console.log("hey, do something..")
                        if (componentClickX <= sliderLineStartingpositionX)
                            sliderValue = 0
                        else if(componentClickX >= sliderLineEndingpositionX)
                            sliderValue = sliderLineEndingpositionX-sliderLineStartingpositionX;
                        else 
                            sliderValue = componentClickX - sliderLineStartingpositionX;

                        d3.select("#" + sliderRectId)
                            .attr("transform", function () {
                                //console.log(componentClickX - sliderLineStartingpositionX)
                                return "translate(" + (sliderValue).toString() + "," +sliderLineStartingpositionY+")";
                            })

                            //console.log("#sliderValueText_"+sliderRectId.replace("SliderAnchor_",""))
                        sliderTxt = d3.select("#sliderValueText_"+sliderRectId.replace("SliderAnchor_",""))
                        .text((ax*sliderValue).toFixed(6));
                    }
            })
            .on('mouseup', function () {
                SliderAnchorclicked = false;
                if (startDrag) {
                    startDrag = false;
                }
                if (edgeStarted) {
                    edgeStarted = false;
                    theEdge = d3.select("#" + selectedcircleId).remove();
                }
            });
    </script>

</body>

</html>